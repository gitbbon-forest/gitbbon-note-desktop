/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Gitbbon. All rights reserved.
 *  Licensed under the MIT License.
 *--------------------------------------------------------------------------------------------*/

import * as vscode from 'vscode';
import { ProjectManager } from './projectManager';
import { GitGraphViewProvider } from './gitGraphViewProvider';
import { GitHubSyncManager } from './githubSyncManager';

/**
 * Extension activation
 */
export async function activate(context: vscode.ExtensionContext): Promise<void> {
	console.log('Gitbbon Manager extension activating...');
	const projectManager = new ProjectManager();
	const githubSyncManager = new GitHubSyncManager(projectManager);

	// Register Git Graph View Provider
	const gitGraphProvider = new GitGraphViewProvider(context.extensionUri);
	context.subscriptions.push(
		vscode.window.registerWebviewViewProvider(GitGraphViewProvider.viewType, gitGraphProvider)
	);

	// Register initialize command (manual trigger)
	const initializeCommand = vscode.commands.registerCommand(
		'gitbbon.manager.initialize',
		async () => {
			await projectManager.startup();
		}
	);
	context.subscriptions.push(initializeCommand);

	// Register Sync Command
	const syncCommand = vscode.commands.registerCommand(
		'gitbbon.manager.sync',
		async () => {
			await githubSyncManager.sync(false); // Interactive mode
			await gitGraphProvider.refresh();
		}
	);
	context.subscriptions.push(syncCommand);

	// Status Bar Item for Sync
	const syncStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
	syncStatusBarItem.text = `$(sync) Sync`;
	syncStatusBarItem.command = 'gitbbon.manager.sync';
	syncStatusBarItem.tooltip = 'GitHubì™€ ë™ê¸°í™”';
	syncStatusBarItem.show();
	context.subscriptions.push(syncStatusBarItem);

	// Register autoCommit command
	const autoCommitCommand = vscode.commands.registerCommand(
		'gitbbon.manager.autoCommit',
		async () => {
			const result = await projectManager.autoCommit();
			console.log('Auto Commit Result:', result);
			if (result.success) {
				await gitGraphProvider.refresh();
			}
			return result;
		}
	);
	context.subscriptions.push(autoCommitCommand);

	// Register reallyFinal command
	const reallyFinalCommand = vscode.commands.registerCommand(
		'gitbbon.manager.reallyFinal',
		async () => {
			const result = await projectManager.reallyFinalCommit();
			console.log('Really Final Result:', result);
			if (result.success) {
				await gitGraphProvider.refresh();
				// Trigger Sync after really final commit (Silent mode)
				console.log('[Extension] Triggering Sync after Really Final Commit (Silent)...');
				githubSyncManager.sync(true)
					.then(() => {
						console.log('[Extension] Post-commit sync completed, refreshing git graph...');
						return gitGraphProvider.refresh();
					})
					.catch(e => console.error('Post-commit sync failed:', e));
			}
			return result;
		}
	);
	context.subscriptions.push(reallyFinalCommand);

	// 30-minute Periodic Sync (Silent mode)
	const syncInterval = setInterval(() => {
		console.log('[Extension] Triggering periodic sync (30m, Silent)...');
		githubSyncManager.sync(true)
			.then(() => {
				console.log('[Extension] Periodic sync completed, refreshing git graph...');
				return gitGraphProvider.refresh();
			})
			.catch(e => console.error('Periodic sync failed:', e));
	}, 30 * 60 * 1000); // 30 minutes
	context.subscriptions.push({ dispose: () => clearInterval(syncInterval) });


	// Startup logic
	// We run this slightly deferred to let VS Code settle, though 'activate' is already part of startup.
	// We don't want to block extension activation too long, so we run async.
	projectManager.startup().then(async () => {
		// Focus Git Graph View on startup
		// The command 'gitbbon.gitGraph.focus' is automatically generated by VS Code for the view with ID 'gitbbon.gitGraph'.
		await vscode.commands.executeCommand('gitbbon.gitGraph.focus').then(undefined, err => {
			console.warn('[Extension] Could not focus Git Graph view:', err);
		});

		// Attempt initial sync in SILENT mode.
		// If user never authenticated, this will do nothing.
		console.log('[Extension] Triggering startup sync (Silent)...');
		githubSyncManager.sync(true)
			.then(() => {
				console.log('[Extension] Startup sync completed, refreshing git graph...');
				return gitGraphProvider.refresh();
			})
			.catch(e => console.error('Startup sync failed:', e));
	}).catch(err => {
		console.error('Startup failed:', err);
	});

	// Comparison Mode Switch Command
	// í˜„ì¬ ì»¤ë°‹ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì €ì¥ (ëª¨ë“œ ë³€ê²½ ê°„ ìœ ì§€)
	let currentCommitContext: { historyItemId: string; rootUri: vscode.Uri } | undefined;

	const switchComparisonModeCommand = vscode.commands.registerCommand(
		'gitbbon.switchComparisonMode',
		async (args: { mode: string; multiDiffSource: string }) => {
			console.log('Switch Comparison Mode triggered:', args);
			if (!args.multiDiffSource) {
				vscode.window.showErrorMessage('No Multi Diff Source provided.');
				return;
			}

			try {
				const uri = vscode.Uri.parse(args.multiDiffSource);
				console.log('uri.scheme:', uri.scheme);

				// scm-history-item ìŠ¤í‚´ì¸ ê²½ìš° ì»¨í…ìŠ¤íŠ¸ ê°±ì‹ 
				if (uri.scheme === 'scm-history-item') {
					const query = JSON.parse(uri.query);
					const { historyItemId } = query;
					const rootUri = vscode.workspace.workspaceFolders?.[0]?.uri;
					if (historyItemId && rootUri) {
						currentCommitContext = { historyItemId, rootUri };
						console.log('Updated commit context:', currentCommitContext);
					}
				}

				// ì €ì¥ëœ ì»¨í…ìŠ¤íŠ¸ê°€ ì—†ìœ¼ë©´ ì—ëŸ¬
				if (!currentCommitContext) {
					vscode.window.showWarningMessage('ë¹„êµ ëª¨ë“œ ë³€ê²½ì€ Git Graphì—ì„œ ì»¤ë°‹ì„ ë‹¤ì‹œ ì„ íƒí•´ ì£¼ì„¸ìš”.');
					return;
				}

				const { historyItemId, rootUri } = currentCommitContext;

				// Get current branch name dynamically
				const getCurrentBranch = (): Promise<string> => {
					return new Promise((resolve, reject) => {
						const cp = require('child_process');
						cp.exec('git rev-parse --abbrev-ref HEAD', { cwd: rootUri.fsPath }, (err: Error | null, stdout: string) => {
							if (err) {
								reject(err);
								return;
							}
							resolve(stdout.trim());
						});
					});
				};

				// Resolve branch/ref name to commit hash
				const resolveRefToCommitHash = (ref: string): Promise<string> => {
					return new Promise((resolve, reject) => {
						const cp = require('child_process');
						cp.exec(`git rev-parse ${ref}`, { cwd: rootUri.fsPath }, (err: Error | null, stdout: string) => {
							if (err) {
								reject(err);
								return;
							}
							resolve(stdout.trim());
						});
					});
				};

				let parentCommitId: string | undefined = undefined;


				console.log("ğŸš€ ~ activate ~ args.mode:", args.mode)
				switch (args.mode) {
					case 'savepoint':
						// í˜„ì¬ ë¸Œëœì¹˜ì˜ ë§ˆì§€ë§‰ ë²„ì „(ì»¤ë°‹ í•´ì‹œ)ê³¼ ë¹„êµ
						try {
							const currentBranch = await getCurrentBranch();
							const commitHash = await resolveRefToCommitHash(currentBranch);
							parentCommitId = commitHash;
							console.log(`Savepoint mode: comparing with '${currentBranch}' -> commit ${commitHash}`);
						} catch (e) {
							console.error('Failed to resolve branch to commit:', e);
						}
						break;
					case 'draft':
						// auto-save/í˜„ì¬ë¸Œëœì¹˜ì˜ ì»¤ë°‹ í•´ì‹œì™€ ë¹„êµ
						try {
							const currentBranch = await getCurrentBranch();
							const autoSaveBranch = `auto-save/${currentBranch}`;
							const commitHash = await resolveRefToCommitHash(autoSaveBranch);
							parentCommitId = commitHash;
							console.log(`Draft mode: comparing with '${autoSaveBranch}' -> commit ${commitHash}`);
						} catch (e) {
							console.error('Failed to resolve auto-save branch to commit:', e);
							vscode.window.showWarningMessage(`auto-save ë¸Œëœì¹˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
						}
						break;
					case 'default':
						parentCommitId = undefined; // Default behavior (compare with parent)
						break;
				}

				console.log(`Switching mode to ${args.mode}, parent: ${parentCommitId}`);

				if (!parentCommitId) {
					// Default ëª¨ë“œ: ê¸°ì¡´ Core ëª…ë ¹ì–´ ì‚¬ìš©
					await vscode.commands.executeCommand(
						'gitbbon.openCommitInMultiDiffEditor',
						rootUri,
						historyItemId,
						undefined
					);
				} else {
					// Custom ë¹„êµ: git diffë¥¼ ì§ì ‘ ì‹¤í–‰í•˜ì—¬ íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
					const getChangedFiles = (): Promise<{ status: string, file: string, originalFile?: string }[]> => {
						return new Promise((resolve, reject) => {
							const cp = require('child_process');
							cp.exec(
								`git diff --name-status ${parentCommitId}..${historyItemId}`,
								{ cwd: rootUri.fsPath },
								(err: Error | null, stdout: string) => {
									if (err) {
										reject(err);
										return;
									}
									const files = stdout.trim().split('\n').filter(l => l).map(line => {
										const parts = line.split('\t');
										const status = parts[0];
										if (status.startsWith('R')) {
											// Renamed: R100\toldname\tnewname
											return { status: 'R', file: parts[2], originalFile: parts[1] };
										}
										return { status, file: parts[1] };
									});
									resolve(files);
								}
							);
						});
					};

					try {
						const changedFiles = await getChangedFiles();
						console.log(`[switchComparisonMode] Changed files:`, changedFiles);

						if (changedFiles.length === 0) {
							vscode.window.showInformationMessage('ë³€ê²½ëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.');
							return;
						}

						// git: ìŠ¤í‚´ URI ìƒì„± í—¬í¼
						const toGitUri = (filePath: string, ref: string): vscode.Uri => {
							const fileUri = vscode.Uri.file(`${rootUri.fsPath}/${filePath}`);
							const params = { path: fileUri.fsPath, ref };
							return fileUri.with({
								scheme: 'git',
								query: JSON.stringify(params)
							});
						};

						// MultiDiffEditorInput resources êµ¬ì„±
						// savepoint/draft ëª¨ë“œ: parentCommitIdê°€ ì´ì „ ë²„ì „ì´ë¯€ë¡œ ì™¼ìª½ì— í‘œì‹œ
						// ë”°ë¼ì„œ originalUri = parentCommitId, modifiedUri = historyItemId
						// í•˜ì§€ë§Œ ì‚¬ìš©ìê°€ ì›í•˜ëŠ” ê²ƒ: Save Point/auto-save(ì´ì „)ê°€ ì™¼ìª½
						// í˜„ì¬ ì»¤ë°‹(historyItemId)ì´ ì™¼ìª½, Save Point(parentCommitId)ê°€ ì˜¤ë¥¸ìª½ì´ ë˜ì–´ì•¼ í•¨
						const resources = changedFiles.map(change => {
							let originalUri: vscode.Uri | undefined;
							let modifiedUri: vscode.Uri | undefined;

							// savepoint/draft: í˜„ì¬ ì»¤ë°‹(historyItemId)ì´ ì™¼ìª½, Save Point/auto-saveê°€ ì˜¤ë¥¸ìª½
							switch (change.status) {
								case 'A': // Added (í˜„ì¬ ì»¤ë°‹ì—ì„œ ì¶”ê°€ë¨ â†’ ì´ ê²½ìš° ìŠ¤ì™‘í•˜ë©´ ì‚­ì œëœ ê²ƒì²˜ëŸ¼ ë³´ì„)
									// ìŠ¤ì™‘: ì™¼ìª½=historyItemId(ì—†ìŒ), ì˜¤ë¥¸ìª½=parentCommitId(ìˆìŒ) â†’ Deletedì²˜ëŸ¼ í‘œì‹œ
									originalUri = toGitUri(change.file, historyItemId);
									break;
								case 'D': // Deleted (í˜„ì¬ ì»¤ë°‹ì—ì„œ ì‚­ì œë¨)
									// ìŠ¤ì™‘: ì™¼ìª½=historyItemId(ìˆìŒ), ì˜¤ë¥¸ìª½=parentCommitId(ì—†ìŒ) â†’ Addedì²˜ëŸ¼ í‘œì‹œ
									modifiedUri = toGitUri(change.file, parentCommitId!);
									break;
								case 'R': // Renamed
									originalUri = toGitUri(change.file, historyItemId);
									modifiedUri = toGitUri(change.originalFile!, parentCommitId!);
									break;
								default: // Modified
									originalUri = toGitUri(change.file, historyItemId);
									modifiedUri = toGitUri(change.file, parentCommitId!);
									break;
							}

							return { originalUri, modifiedUri };
						});

						// Multi Diff Editor ì—´ê¸°
						const label = `${historyItemId.substring(0, 8)} vs ${parentCommitId.substring(0, 8)}`;
						await vscode.commands.executeCommand('_workbench.openMultiDiffEditor', {
							title: label,
							resources
						});

					} catch (e) {
						console.error('[switchComparisonMode] Failed to get changed files:', e);
						vscode.window.showErrorMessage('ë³€ê²½ëœ íŒŒì¼ ëª©ë¡ì„ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
					}
				}

			} catch (e) {
				console.error('Failed to switch comparison mode:', e);
				vscode.window.showErrorMessage('Failed to switch comparison mode.');
			}
		}
	);
	context.subscriptions.push(switchComparisonModeCommand);

	console.log('Gitbbon Manager extension activated!');
}

/**
 * Extension deactivation
 */
export function deactivate(): void {
	console.log('Gitbbon Manager extension deactivated');
}
