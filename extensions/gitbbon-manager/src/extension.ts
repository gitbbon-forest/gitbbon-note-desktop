/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Gitbbon. All rights reserved.
 *  Licensed under the MIT License.
 *--------------------------------------------------------------------------------------------*/

import * as vscode from 'vscode';
import { ProjectManager } from './projectManager';
import { GitGraphViewProvider } from './gitGraphViewProvider';
import { GitHubSyncManager } from './githubSyncManager';

/**
 * Extension activation
 */
export async function activate(context: vscode.ExtensionContext): Promise<void> {
	console.log('Gitbbon Manager extension activating...');
	const projectManager = new ProjectManager();
	const githubSyncManager = new GitHubSyncManager(projectManager);

	// Register Git Graph View Provider
	const gitGraphProvider = new GitGraphViewProvider(context.extensionUri);
	context.subscriptions.push(
		vscode.window.registerWebviewViewProvider(GitGraphViewProvider.viewType, gitGraphProvider)
	);

	// Register initialize command (manual trigger)
	const initializeCommand = vscode.commands.registerCommand(
		'gitbbon.manager.initialize',
		async () => {
			await projectManager.startup();
		}
	);
	context.subscriptions.push(initializeCommand);

	// Register Sync Command
	const syncCommand = vscode.commands.registerCommand(
		'gitbbon.manager.sync',
		async () => {
			await githubSyncManager.sync(false); // Interactive mode
			await gitGraphProvider.refresh();
		}
	);
	context.subscriptions.push(syncCommand);

	// Status Bar Item for Sync
	const syncStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
	syncStatusBarItem.text = `$(sync) Sync`;
	syncStatusBarItem.command = 'gitbbon.manager.sync';
	syncStatusBarItem.tooltip = 'GitHubì™€ ë™ê¸°í™”';
	syncStatusBarItem.show();
	context.subscriptions.push(syncStatusBarItem);

	// Register autoCommit command
	const autoCommitCommand = vscode.commands.registerCommand(
		'gitbbon.manager.autoCommit',
		async () => {
			const result = await projectManager.autoCommit();
			console.log('Auto Commit Result:', result);
			if (result.success) {
				await gitGraphProvider.refresh();
			}
			return result;
		}
	);
	context.subscriptions.push(autoCommitCommand);

	// Register reallyFinal command
	const reallyFinalCommand = vscode.commands.registerCommand(
		'gitbbon.manager.reallyFinal',
		async () => {
			const result = await projectManager.reallyFinalCommit();
			console.log('Really Final Result:', result);
			if (result.success) {
				await gitGraphProvider.refresh();
				// Trigger Sync after really final commit (Silent mode)
				console.log('[Extension] Triggering Sync after Really Final Commit (Silent)...');
				githubSyncManager.sync(true)
					.then(() => {
						console.log('[Extension] Post-commit sync completed, refreshing git graph...');
						return gitGraphProvider.refresh();
					})
					.catch(e => console.error('Post-commit sync failed:', e));
			}
			return result;
		}
	);
	context.subscriptions.push(reallyFinalCommand);

	// 30-minute Periodic Sync (Silent mode)
	const syncInterval = setInterval(() => {
		console.log('[Extension] Triggering periodic sync (30m, Silent)...');
		githubSyncManager.sync(true)
			.then(() => {
				console.log('[Extension] Periodic sync completed, refreshing git graph...');
				return gitGraphProvider.refresh();
			})
			.catch(e => console.error('Periodic sync failed:', e));
	}, 30 * 60 * 1000); // 30 minutes
	context.subscriptions.push({ dispose: () => clearInterval(syncInterval) });


	// Startup logic
	// We run this slightly deferred to let VS Code settle, though 'activate' is already part of startup.
	// We don't want to block extension activation too long, so we run async.
	projectManager.startup().then(async () => {
		// Focus Git Graph View on startup
		// The command 'gitbbon.gitGraph.focus' is automatically generated by VS Code for the view with ID 'gitbbon.gitGraph'.
		await vscode.commands.executeCommand('gitbbon.gitGraph.focus').then(undefined, err => {
			console.warn('[Extension] Could not focus Git Graph view:', err);
		});

		// Attempt initial sync in SILENT mode.
		// If user never authenticated, this will do nothing.
		console.log('[Extension] Triggering startup sync (Silent)...');
		githubSyncManager.sync(true)
			.then(() => {
				console.log('[Extension] Startup sync completed, refreshing git graph...');
				return gitGraphProvider.refresh();
			})
			.catch(e => console.error('Startup sync failed:', e));
	}).catch(err => {
		console.error('Startup failed:', err);
	});

	// Restore File Command
	const restoreFileCommand = vscode.commands.registerCommand('gitbbon.restoreFile', async (commitHash: string, fileUri: vscode.Uri) => {
		const workspaceFolder = vscode.workspace.getWorkspaceFolder(fileUri);
		if (!workspaceFolder) {
			vscode.window.showErrorMessage('ì›Œí¬ìŠ¤í˜ì´ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
			return;
		}

		try {
			const relativePath = vscode.workspace.asRelativePath(fileUri);

			const confirm = await vscode.window.showWarningMessage(
				`'${relativePath}' íŒŒì¼ì„ ${commitHash.substring(0, 7)} ë²„ì „ìœ¼ë¡œ ë³µêµ¬í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (í˜„ì¬ ë³€ê²½ì‚¬í•­ì€ ë®ì–´ì“°ì—¬ì§‘ë‹ˆë‹¤)`,
				'ë³µêµ¬',
				'ì·¨ì†Œ'
			);

			if (confirm !== 'ë³µêµ¬') {
				return;
			}

			// git checkout {commitHash} -- {relativePath}
			const { exec } = require('child_process');
			const command = `git checkout ${commitHash} -- "${relativePath}"`;

			await new Promise((resolve, reject) => {
				exec(command, { cwd: workspaceFolder.uri.fsPath }, (error: any, stdout: any, stderr: any) => {
					if (error) {
						reject(error);
						return;
					}
					resolve(stdout);
				});
			});

			vscode.window.showInformationMessage(`${relativePath} íŒŒì¼ì´ ë³µêµ¬ë˜ì—ˆìŠµë‹ˆë‹¤.`);
		} catch (error) {
			console.error('File restore failed:', error);
			vscode.window.showErrorMessage(`íŒŒì¼ ë³µêµ¬ ì‹¤íŒ¨: ${error}`);
		}
	});
	context.subscriptions.push(restoreFileCommand);

	// Comparison Mode Switch Command

	// í˜„ì¬ ì»¤ë°‹ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì €ì¥ (ëª¨ë“œ ë³€ê²½ ê°„ ìœ ì§€)
	let currentCommitContext: { historyItemId: string; rootUri: vscode.Uri } | undefined;

	const switchComparisonModeCommand = vscode.commands.registerCommand(
		'gitbbon.switchComparisonMode',
		async (args: { mode: string; multiDiffSource: string }) => {
			console.log('Switch Comparison Mode triggered:', args);
			if (!args.multiDiffSource) {
				vscode.window.showErrorMessage('No Multi Diff Source provided.');
				return;
			}

			try {
				const uri = vscode.Uri.parse(args.multiDiffSource);
				console.log('uri.scheme:', uri.scheme);

				// scm-history-item ìŠ¤í‚´ì¸ ê²½ìš° ì»¨í…ìŠ¤íŠ¸ ê°±ì‹ 
				if (uri.scheme === 'scm-history-item') {
					const query = JSON.parse(uri.query);
					const { historyItemId } = query;
					const rootUri = vscode.workspace.workspaceFolders?.[0]?.uri;
					if (historyItemId && rootUri) {
						currentCommitContext = { historyItemId, rootUri };
						console.log('Updated commit context:', currentCommitContext);
					}
				}

				// ì €ì¥ëœ ì»¨í…ìŠ¤íŠ¸ê°€ ì—†ìœ¼ë©´ ì—ëŸ¬
				if (!currentCommitContext) {
					vscode.window.showWarningMessage('ë¹„êµ ëª¨ë“œ ë³€ê²½ì€ Git Graphì—ì„œ ì»¤ë°‹ì„ ë‹¤ì‹œ ì„ íƒí•´ ì£¼ì„¸ìš”.');
					return;
				}

				const { historyItemId, rootUri } = currentCommitContext;

				// Get current branch name dynamically
				const getCurrentBranch = (): Promise<string> => {
					return new Promise((resolve, reject) => {
						const cp = require('child_process');
						cp.exec('git rev-parse --abbrev-ref HEAD', { cwd: rootUri.fsPath }, (err: Error | null, stdout: string) => {
							if (err) {
								reject(err);
								return;
							}
							resolve(stdout.trim());
						});
					});
				};

				// Resolve branch/ref name to commit hash
				const resolveRefToCommitHash = (ref: string): Promise<string> => {
					return new Promise((resolve, reject) => {
						const cp = require('child_process');
						cp.exec(`git rev-parse ${ref}`, { cwd: rootUri.fsPath }, (err: Error | null, stdout: string) => {
							if (err) {
								reject(err);
								return;
							}
							resolve(stdout.trim());
						});
					});
				};

				let parentCommitId: string | undefined = undefined;


				console.log("ğŸš€ ~ activate ~ args.mode:", args.mode)
				switch (args.mode) {
					case 'savepoint':
						// í˜„ì¬ ë¸Œëœì¹˜ì˜ ë§ˆì§€ë§‰ ë²„ì „(ì»¤ë°‹ í•´ì‹œ)ê³¼ ë¹„êµ
						try {
							const currentBranch = await getCurrentBranch();
							const commitHash = await resolveRefToCommitHash(currentBranch);
							parentCommitId = commitHash;
							console.log(`Savepoint mode: comparing with '${currentBranch}' -> commit ${commitHash}`);
						} catch (e) {
							console.error('Failed to resolve branch to commit:', e);
						}
						break;
					case 'draft':
						// auto-save/í˜„ì¬ë¸Œëœì¹˜ì˜ ì»¤ë°‹ í•´ì‹œì™€ ë¹„êµ
						try {
							const currentBranch = await getCurrentBranch();
							const autoSaveBranch = `auto-save/${currentBranch}`;
							const commitHash = await resolveRefToCommitHash(autoSaveBranch);
							parentCommitId = commitHash;
							console.log(`Draft mode: comparing with '${autoSaveBranch}' -> commit ${commitHash}`);
						} catch (e) {
							console.error('Failed to resolve auto-save branch to commit:', e);
							vscode.window.showWarningMessage(`auto-save ë¸Œëœì¹˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
						}
						break;
					case 'default':
						// ì´ì „ ë²„ì „(ì»¤ë°‹ì˜ ì‹¤ì œ ë¶€ëª¨)ê³¼ ë¹„êµ
						try {
							const commitParent = await resolveRefToCommitHash(`${historyItemId}^`);
							parentCommitId = commitParent;
							console.log(`Default mode: comparing with parent commit ${commitParent}`);
						} catch (e) {
							console.error('Failed to resolve parent commit:', e);
							vscode.window.showWarningMessage('ë¶€ëª¨ ì»¤ë°‹ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
						}
						break;
				}

				console.log(`Switching mode to ${args.mode}, parent: ${parentCommitId}`);

				if (!parentCommitId) {
					// Default ëª¨ë“œ: ê¸°ì¡´ Core ëª…ë ¹ì–´ ì‚¬ìš©
					await vscode.commands.executeCommand(
						'gitbbon.openCommitInMultiDiffEditor',
						rootUri,
						historyItemId,
						undefined
					);
				} else {
					// Custom ë¹„êµ: git diffë¥¼ ì§ì ‘ ì‹¤í–‰í•˜ì—¬ íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
					const getChangedFiles = (): Promise<{ status: string, file: string, originalFile?: string }[]> => {
						return new Promise((resolve, reject) => {
							const cp = require('child_process');
							cp.exec(
								`git diff --name-status ${parentCommitId}..${historyItemId}`,
								{ cwd: rootUri.fsPath },
								(err: Error | null, stdout: string) => {
									if (err) {
										reject(err);
										return;
									}
									const files = stdout.trim().split('\n').filter(l => l).map(line => {
										const parts = line.split('\t');
										const status = parts[0];
										if (status.startsWith('R')) {
											// Renamed: R100\toldname\tnewname
											return { status: 'R', file: parts[2], originalFile: parts[1] };
										}
										return { status, file: parts[1] };
									});
									resolve(files);
								}
							);
						});
					};

					try {
						const changedFiles = await getChangedFiles();
						console.log(`[switchComparisonMode] Changed files:`, changedFiles);

						if (changedFiles.length === 0) {
							vscode.window.showInformationMessage('ë³€ê²½ëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.');
							return;
						}

						// git: ìŠ¤í‚´ URI ìƒì„± í—¬í¼
						const toGitUri = (filePath: string, ref: string): vscode.Uri => {
							const fileUri = vscode.Uri.file(`${rootUri.fsPath}/${filePath}`);
							const params = { path: fileUri.fsPath, ref };
							return fileUri.with({
								scheme: 'git',
								query: JSON.stringify(params)
							});
						};

						// MultiDiffEditorInput resources êµ¬ì„±
						// default ëª¨ë“œ: ë¶€ëª¨(parentCommitId)ê°€ ì™¼ìª½, í˜„ì¬(historyItemId)ê°€ ì˜¤ë¥¸ìª½ (ì¼ë°˜ì ì¸ diff)
						// savepoint/draft ëª¨ë“œ: í˜„ì¬(historyItemId)ê°€ ì™¼ìª½, Save Point/auto-saveê°€ ì˜¤ë¥¸ìª½
						const shouldSwap = args.mode === 'savepoint' || args.mode === 'draft';

						const resources = changedFiles.map(change => {
							let originalUri: vscode.Uri | undefined;
							let modifiedUri: vscode.Uri | undefined;

							// ì™¼ìª½ = original, ì˜¤ë¥¸ìª½ = modified
							const leftRef = shouldSwap ? historyItemId : parentCommitId!;
							const rightRef = shouldSwap ? parentCommitId! : historyItemId;

							switch (change.status) {
								case 'A': // Added
									if (shouldSwap) {
										originalUri = toGitUri(change.file, historyItemId);
									} else {
										modifiedUri = toGitUri(change.file, historyItemId);
									}
									break;
								case 'D': // Deleted
									if (shouldSwap) {
										modifiedUri = toGitUri(change.file, parentCommitId!);
									} else {
										originalUri = toGitUri(change.file, parentCommitId!);
									}
									break;
								case 'R': // Renamed
									originalUri = toGitUri(shouldSwap ? change.file : change.originalFile!, leftRef);
									modifiedUri = toGitUri(shouldSwap ? change.originalFile! : change.file, rightRef);
									break;
								default: // Modified
									originalUri = toGitUri(change.file, leftRef);
									modifiedUri = toGitUri(change.file, rightRef);
									break;
							}

							return { originalUri, modifiedUri };
						});

						// Multi Diff Editor ì—´ê¸°
						const label = `${historyItemId.substring(0, 8)} vs ${parentCommitId.substring(0, 8)}`;
						await vscode.commands.executeCommand('_workbench.openMultiDiffEditor', {
							title: label,
							resources
						});

					} catch (e) {
						console.error('[switchComparisonMode] Failed to get changed files:', e);
						vscode.window.showErrorMessage('ë³€ê²½ëœ íŒŒì¼ ëª©ë¡ì„ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
					}
				}

			} catch (e) {
				console.error('Failed to switch comparison mode:', e);
				vscode.window.showErrorMessage('Failed to switch comparison mode.');
			}
		}
	);
	context.subscriptions.push(switchComparisonModeCommand);

	// Restore to Version Command
	const restoreToVersionCommand = vscode.commands.registerCommand(
		'gitbbon.restoreToVersion',
		async (args: { commitHash: string; multiDiffSource: string }) => {
			console.log('Restore to Version triggered:', args);

			if (!args.commitHash) {
				vscode.window.showErrorMessage('No commit hash provided for restoration.');
				return;
			}

			// 1. Resolve Root URI
			let rootUri: vscode.Uri | undefined;
			if (args.multiDiffSource) {
				try {
					const uri = vscode.Uri.parse(args.multiDiffSource);
					if (uri.scheme === 'scm-history-item') {
						rootUri = vscode.workspace.workspaceFolders?.[0]?.uri; // fallback to first folder usually works
					}
				} catch (e) {
					console.error('Failed to parse multiDiffSource:', e);
				}
			}
			if (!rootUri) {
				rootUri = vscode.workspace.workspaceFolders?.[0]?.uri;
			}
			if (!rootUri) {
				vscode.window.showErrorMessage('No workspace folder found.');
				return;
			}

			const cwd = rootUri.fsPath;
			const targetCommitHash = args.commitHash;

			// Confirm with user
			const confirm = await vscode.window.showWarningMessage(
				`í˜„ì¬ ìƒíƒœë¥¼ ì»¤ë°‹ '${targetCommitHash.substring(0, 7)}' ìƒíƒœë¡œ ë³µì›í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (í˜„ì¬ ë‚´ìš©ì€ ìë™ìœ¼ë¡œ ë°±ì—…ë©ë‹ˆë‹¤)`,
				{ modal: true },
				'ë³µì›í•˜ê¸°'
			);
			if (confirm !== 'ë³µì›í•˜ê¸°') {
				return;
			}

			try {
				await vscode.window.withProgress({
					location: vscode.ProgressLocation.Notification,
					title: "ë²„ì „ ë³µì› ì¤‘...",
					cancellable: false
				}, async (progress) => {

					// Step 1: Safety Check & Backup (Really Final)
					progress.report({ message: "í˜„ì¬ ì‘ì—… ë‚´ìš© ë°±ì—… ì¤‘..." });
					// Check for uncommitted changes
					const hasChanges = await new Promise<boolean>((resolve) => {
						const cp = require('child_process');
						cp.exec('git status --porcelain', { cwd }, (err: Error | null, stdout: string) => {
							resolve(!!(stdout && stdout.trim().length > 0));
						});
					});

					if (hasChanges) {
						console.log('[Restore] Changes detected, triggering Really Final...');
						const backupResult = await projectManager.reallyFinalCommit();
						if (!backupResult.success) {
							throw new Error(`Backup failed: ${backupResult.message}`);
						}
					} else {
						console.log('[Restore] Clean state, skipping backup.');
					}

					// Step 2: Get Target Commit Title
					progress.report({ message: "íƒ€ê²Ÿ ì»¤ë°‹ ì •ë³´ ì¡°íšŒ ì¤‘..." });
					const targetTitle = await new Promise<string>((resolve, reject) => {
						const cp = require('child_process');
						cp.exec(`git log -1 --pretty=%s ${targetCommitHash}`, { cwd }, (err: Error | null, stdout: string) => {
							if (err) {
								reject(err);
							} else {
								resolve(stdout.trim());
							}
						});
					});

					// Step 3: Read Tree (Restore Content)
					progress.report({ message: "ê³¼ê±° ìƒíƒœ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘..." });
					await new Promise<void>((resolve, reject) => {
						const cp = require('child_process');
						// -u: updates the index and checking out files
						// --reset: performs a merge rather than a hard overwrite if possible, but here we want to match target
						// Actually 'git read-tree -u --reset <tree-ish>' matches the index and worktree to the tree-ish.
						cp.exec(`git read-tree -u --reset ${targetCommitHash}`, { cwd }, (err: Error | null, stderr: string) => {
							if (err) {
								console.error('git read-tree failed:', stderr);
								reject(err);
							} else {
								resolve();
							}
						});
					});

					// Step 4: Create Restore Commit
					progress.report({ message: "ë³µì› ì»¤ë°‹ ìƒì„± ì¤‘..." });
					const restoreMessage = `ë³µì› : ${targetTitle} (${targetCommitHash.substring(0, 7)})`;
					await new Promise<void>((resolve, reject) => {
						const cp = require('child_process');
						cp.exec(`git commit -m "${restoreMessage}"`, { cwd }, (err: Error | null, stderr: string) => {
							if (err) {
								reject(err);
							} else {
								resolve();
							}
						});
					});

					// Step 5: Sync
					progress.report({ message: "ì›ê²© ì €ì¥ì†Œ ë™ê¸°í™” ì¤‘..." });
					await githubSyncManager.sync(false);

					// Refresh Git Graph
					await gitGraphProvider.refresh();

					vscode.window.showInformationMessage(`ì„±ê³µì ìœ¼ë¡œ ë³µì›ë˜ì—ˆìŠµë‹ˆë‹¤: ${restoreMessage}`);
				});
			} catch (e) {
				console.error('[Restore] Failed:', e);
				vscode.window.showErrorMessage(`ë³µì› ì‹¤íŒ¨: ${e}`);
			}
		}
	);
	context.subscriptions.push(restoreToVersionCommand);

	console.log('Gitbbon Manager extension activated!');
}

/**
 * Extension deactivation
 */
export function deactivate(): void {
	console.log('Gitbbon Manager extension deactivated');
}
